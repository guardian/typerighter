package matchers

import model._
import org.scalatest.flatspec.AsyncFlatSpec
import org.scalatest.matchers.should.Matchers
import com.softwaremill.diffx.scalatest.DiffMatcher._

import services.MatcherRequest
import utils.Text
import scala.util.matching.Regex
import scala.concurrent.Future

class RegexMatcherTest extends AsyncFlatSpec with Matchers {
  def createRules(textsToMatch: List[String]) = {
    textsToMatch.zipWithIndex.map { case (text, index) =>
      RegexRule(
        id = s"example-rule-$index",
        category = Category("new-category", "New Category"),
        description = s"Example rule $index",
        suggestions = List(TextSuggestion(s"Suggestion for rule $index")),
        regex = text.r
      )
    }
  }
  val exampleCategory = Category("example-category", "Example category")
  val exampleRule = createRules(List("text"))(0)

  val regexValidator = new RegexMatcher(List(exampleRule))

  def getBlocks(text: String) = List(TextBlock("text-block-id", text, 0, text.length))

  def getMatch(text: String, fromPos: Int, toPos: Int, before: String, after: String, rule: RegexRule = exampleRule, replacement: Option[String] = None, markAsCorrect: Boolean = false) = RuleMatch(
    rule = rule,
    fromPos = fromPos,
    toPos = toPos,
    precedingText = before,
    subsequentText = after,
    matchedText = text,
    message = rule.description,
    shortMessage = Some(rule.description),
    suggestions = rule.suggestions,
    replacement = replacement.map(TextSuggestion(_)),
    matchContext = Text.getMatchTextSnippet(before, text, after),
    matcherType = RegexMatcher.getType(),
    markAsCorrect = markAsCorrect
  )

  def checkTextWithRegex(regex: Regex, replacement: String, text: String): Future[List[RuleMatch]] = {
    val rule = RegexRule(
      id = "test-rule",
      description = "test-description",
      category = Category("test-category", "Test Category"),
      regex = regex,
      replacement = Some(TextSuggestion(replacement))
    )

    val validator = new RegexMatcher(List(rule))

    validator.check(MatcherRequest(getBlocks(text)))
  }

  "check" should "report single matches in short text" in {
    val sampleText = "example text is here"

    val eventuallyMatches = regexValidator.check(
      MatcherRequest(getBlocks(sampleText))
    )
    eventuallyMatches.map { matches =>
      matches should matchTo(List(
        getMatch("text", 8, 12, "example ", " is here")
      ))
    }
  }

  "check" should "report single matches in long text" in {
    val sampleText = """
                       | 123456789 123456789 123456789
                       | 123456789 123456789 123456789
                       | 123456789 123456789 123456789
                       | 123456789 123456789 123456789
                       | text
                       | 123456789 123456789 123456789
                       | 123456789 123456789 123456789
                       | 123456789 123456789 123456789
                       | 123456789 123456789 123456789
                       |""".stripMargin.replace("\n", "")

    val before = """
                       |123456789
                       | 123456789 123456789 123456789
                       | 123456789 123456789 123456789
                       | 123456789 123456789 123456789
                       | """.stripMargin.replace("\n", "")
    val after = """
                       | 123456789 123456789 123456789
                       | 123456789 123456789 123456789
                       | 123456789 123456789 123456789
                       | 123456789
                       |""".stripMargin.replace("\n", "")

    val eventuallyMatches = regexValidator.check(
      MatcherRequest(getBlocks(sampleText))
    )
    eventuallyMatches.map { matches =>
      matches should matchTo(List(
        getMatch("text", 121, 125, before, after)
      ))
    }
  }

  "check" should "report multiple matches" in {
    val eventuallyMatches = regexValidator.check(
      MatcherRequest(getBlocks("text text text"))
    )
    eventuallyMatches.map { matches =>
      matches should matchTo(List(
        getMatch("text", 0, 4, "", " text text"),
        getMatch("text", 5, 9, "text ", " text"),
        getMatch("text", 10, 14, "text text ", "")
      ))
    }
  }

  "check" should "supersede matches generated by early rules if they overlap with matches generated by later rules" in {
    val overlapRules = createRules(List("to", "ton", "one", "got"))
    val overlapValidator = new RegexMatcher(overlapRules)
    val eventuallyMatches = overlapValidator.check(
      MatcherRequest(getBlocks("tone ton goto"))
    )
    eventuallyMatches.map { matches =>
      matches.size shouldBe 3
      matches(0) should matchTo(getMatch("ton", 5, 8, "tone ", " goto", overlapRules(1)))
      matches(1) should matchTo(getMatch("one", 1, 4, "t", " ton goto", overlapRules(2)))
      matches(2) should matchTo(getMatch("got", 9, 12, "tone ton ", "o", overlapRules(3)))
    }
  }

  "check" should "use substitions when generating replacements" in {
    val rule = RegexRule(
      id = s"example-rule",
      category = Category("new-category", "New Category"),
      description = s"Example rule",
      replacement = Some(TextSuggestion("tea$1")),
      regex = "\\btea-? ?(shop|bag|leaf|leaves|pot)".r
    )

    val validator = new RegexMatcher(List(rule))
    val eventuallyMatches = validator.check(
      MatcherRequest(getBlocks("I'm a little tea pot"))
    )

    eventuallyMatches.map { matches =>
      matches.size shouldBe 1
      val expectedReplacement = Some("teapot")
      val expectedMatch = getMatch("tea pot", 13, 20, "I'm a little ", "", rule, expectedReplacement)
      matches(0) should matchTo(expectedMatch)
      matches(0).markAsCorrect shouldBe false
    }
  }

  "check" should "apply substitutions when computing `markAsCorrect`" in {
    val rule = RegexRule(
      id = s"example-rule",
      category = Category("new-category", "New Category"),
      description = s"Example rule",
      replacement = Some(TextSuggestion("tea$1")),
      regex = "\\btea-? ?(shop|bag|leaf|leaves|pot)".r
    )

    val validator = new RegexMatcher(List(rule))
    val eventuallyMatches = validator.check(
      MatcherRequest(getBlocks("I'm a little teapot"))
    )

    eventuallyMatches.map { matches =>
      matches.size shouldBe 1
      val expectedReplacement = Some("teapot")
      val expectedMatch = getMatch("teapot", 13, 19, "I'm a little ", "", rule, expectedReplacement, markAsCorrect = true)
      matches(0) should matchTo(expectedMatch)
    }
  }

  "check" should "apply substitutions when computing `markAsCorrect` - real world case" in {
    val rule = RegexRule(
      id = s"example-rule",
      category = Category("new-category", "New Category"),
      description = s"Example rule",
      replacement = Some(TextSuggestion("Booker prize")),
      regex = "(?i)\\b(Man)? ?Booker prize".r
    )

    val validator = new RegexMatcher(List(rule))
    val eventuallyMatches = validator.check(
      MatcherRequest(getBlocks("Somebody has won the Booker prize for their first novel"))
    )

    eventuallyMatches.map { matches =>
      matches.size shouldBe 1
      matches(0).replacement shouldBe Some(TextSuggestion(" Booker prize"))
      matches(0).markAsCorrect shouldBe true
    }
  }

   "check" should "handle multiple substitions" in {
    val rule = RegexRule(
      id = s"example-rule",
      category = Category("new-category", "New Category"),
      description = s"Example rule",
      replacement = Some(TextSuggestion("$1-$2-long")),
      regex = "\\b(one|two|three|four|five|six|seven|eight|nine|\\d)-? (year|day|month|week|mile)-? long".r
    )

    val validator = new RegexMatcher(List(rule))
    val eventuallyMatches = validator.check(
      MatcherRequest(getBlocks("A nine month long sabbatical"))
    )

    eventuallyMatches.map { matches =>
      matches.size shouldBe 1
      val expectedReplacement = Some("nine-month-long")
      val expectedMatch = getMatch("nine month long", 2, 17, "A ", " sabbatical", rule, expectedReplacement)
      matches(0) should matchTo(expectedMatch)
    }
  }

  behavior of "capitalisations"

  it should "transform suggestions to respect sentence starts, to avoid suggesting capping down – preserve current case" in {
    val eventuallyMatches = checkTextWithRegex(
      "(?i)\\bcaf(e|é|è|ë|ê)"r,
      "cafe",
      "Allowed to have up to 15 people in their home per day, and this rule applies to holiday accomodation. Cafes, bars, and restaurants will be able to seat 100 indoors and 200 outdoors, within the density limit"
    )

    eventuallyMatches.map { matches =>
      matches.size shouldBe 1
      val firstMatch = matches(0)
      firstMatch.replacement shouldBe Some(TextSuggestion("Cafe"))
      firstMatch.markAsCorrect shouldBe true
    }
  }

  it should "transform suggestions to respect sentence starts, to avoid suggesting capping down – cap up sentence start" in {
    val eventuallyMatches = checkTextWithRegex(
      "(?i)\\bcaf(e|é|è|ë|ê)"r,
      "cafe",
      "Allowed to have up to 15 people in their home per day, and this rule applies to holiday accomodation. cafes, bars, and restaurants will be able to seat 100 indoors and 200 outdoors, within the density limit"
    )

    eventuallyMatches.map { matches =>
      matches.size shouldBe 1
      val firstMatch = matches(0)
      firstMatch.replacement shouldBe Some(TextSuggestion("Cafe"))
      firstMatch.markAsCorrect shouldBe false
    }
  }

  it should "should not apply capitalisations when the match does not include the start of the word" in {
    val eventuallyMatches = checkTextWithRegex(
      "(?i)af(e|é|è|ë|ê)"r,
      "afe",
      "Allowed to have up to 15 people in their home per day, and this rule applies to holiday accomodation. Cafes, bars, and restaurants will be able to seat 100 indoors and 200 outdoors, within the density limit"
    )

    eventuallyMatches.map { matches =>
      matches.size shouldBe 1
      val firstMatch = matches(0)
      firstMatch.replacement shouldBe Some(TextSuggestion("afe"))
      firstMatch.markAsCorrect shouldBe true
    }
  }
}
