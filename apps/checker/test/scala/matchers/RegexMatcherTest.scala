package matchers

import com.gu.typerighter
import com.gu.typerighter.model.{
  Category,
  ComparableRegex,
  RegexRule,
  RuleMatch,
  Text,
  TextBlock,
  TextSuggestion
}
import org.scalatest.flatspec.AsyncFlatSpec
import org.scalatest.matchers.should.Matchers
import com.softwaremill.diffx.scalatest.DiffShouldMatcher._
import com.softwaremill.diffx.generic.auto._
import services.MatcherRequest

import scala.concurrent.Future

class RegexMatcherTest extends AsyncFlatSpec with Matchers {
  def createRules(textsToMatch: List[String]) = {
    textsToMatch.zipWithIndex.map { case (text, index) =>
      RegexRule(
        id = s"example-rule-$index",
        category = Category("new-category", "New Category"),
        description = s"Example rule $index",
        suggestions = List(TextSuggestion(s"Suggestion for rule $index")),
        regex = new ComparableRegex(text)
      )
    }
  }
  val exampleCategory = Category("example-category", "Example category")
  val exampleRule = createRules(List("text"))(0)

  val regexValidator = new RegexMatcher(List(exampleRule))

  def getBlocks(text: String) = List(TextBlock("text-block-id", text, 0, text.length))

  def getMatch(
      text: String,
      fromPos: Int,
      toPos: Int,
      before: String,
      after: String,
      rule: RegexRule = exampleRule,
      replacement: Option[String] = None,
      markAsCorrect: Boolean = false
  ) = RuleMatch(
    rule = rule,
    fromPos = fromPos,
    toPos = toPos,
    precedingText = before,
    subsequentText = after,
    matchedText = text,
    message = rule.description,
    shortMessage = Some(rule.description),
    suggestions = rule.suggestions,
    replacement = replacement.map(TextSuggestion(_)),
    matchContext = Text.getMatchTextSnippet(before, text, after),
    markAsCorrect = markAsCorrect
  )

  def checkTextWithRegex(
      regex: ComparableRegex,
      replacement: String,
      text: String
  ): Future[List[RuleMatch]] = {
    val rule = typerighter.model.RegexRule(
      id = "test-rule",
      description = "test-description",
      category = Category("test-category", "Test Category"),
      regex = regex,
      replacement = Some(TextSuggestion(replacement))
    )

    val validator = new RegexMatcher(List(rule))

    validator.check(MatcherRequest(getBlocks(text)))
  }

  "check" should "report single matches in short text" in {
    val sampleText = "example text is here"

    val eventuallyMatches = regexValidator.check(
      MatcherRequest(getBlocks(sampleText))
    )
    eventuallyMatches.map { matches =>
      matches shouldMatchTo (List(
        getMatch("text", 8, 12, "example ", " is here")
      ))
    }
  }

  "check" should "report single matches in long text" in {
    val sampleText = """
                       | 123456789 123456789 123456789
                       | 123456789 123456789 123456789
                       | 123456789 123456789 123456789
                       | 123456789 123456789 123456789
                       | text
                       | 123456789 123456789 123456789
                       | 123456789 123456789 123456789
                       | 123456789 123456789 123456789
                       | 123456789 123456789 123456789
                       |""".stripMargin.replace("\n", "")

    val before = """
                       |123456789
                       | 123456789 123456789 123456789
                       | 123456789 123456789 123456789
                       | 123456789 123456789 123456789
                       | """.stripMargin.replace("\n", "")
    val after = """
                       | 123456789 123456789 123456789
                       | 123456789 123456789 123456789
                       | 123456789 123456789 123456789
                       | 123456789
                       |""".stripMargin.replace("\n", "")

    val eventuallyMatches = regexValidator.check(
      MatcherRequest(getBlocks(sampleText))
    )
    eventuallyMatches.map { matches =>
      matches shouldMatchTo (List(
        getMatch("text", 121, 125, before, after)
      ))
    }
  }

  "check" should "report multiple matches" in {
    val eventuallyMatches = regexValidator.check(
      MatcherRequest(getBlocks("text text text"))
    )
    eventuallyMatches.map { matches =>
      matches shouldMatchTo (List(
        getMatch("text", 0, 4, "", " text text"),
        getMatch("text", 5, 9, "text ", " text"),
        getMatch("text", 10, 14, "text text ", "")
      ))
    }
  }

  "check" should "supersede matches generated by early rules if they overlap with matches generated by later rules" in {
    val overlapRules = createRules(List("to", "ton", "one", "got"))
    val overlapValidator = new RegexMatcher(overlapRules)
    val eventuallyMatches = overlapValidator.check(
      MatcherRequest(getBlocks("tone ton goto"))
    )
    eventuallyMatches.map { matches =>
      matches.size shouldBe 3
      matches(0) shouldMatchTo (getMatch("ton", 5, 8, "tone ", " goto", overlapRules(1)))
      matches(1) shouldMatchTo (getMatch("one", 1, 4, "t", " ton goto", overlapRules(2)))
      matches(2) shouldMatchTo (getMatch("got", 9, 12, "tone ton ", "o", overlapRules(3)))
    }
  }

  "check" should "use substitions when generating replacements" in {
    val rule = typerighter.model.RegexRule(
      id = s"example-rule",
      category = Category("new-category", "New Category"),
      description = s"Example rule",
      replacement = Some(TextSuggestion("tea$1")),
      regex = new ComparableRegex("\\btea-? ?(shop|bag|leaf|leaves|pot)")
    )

    val validator = new RegexMatcher(List(rule))
    val eventuallyMatches = validator.check(
      MatcherRequest(getBlocks("I'm a little tea pot"))
    )

    eventuallyMatches.map { matches =>
      matches.size shouldBe 1
      val expectedReplacement = Some("teapot")
      val expectedMatch =
        getMatch("tea pot", 13, 20, "I'm a little ", "", rule, expectedReplacement)
      matches(0) shouldMatchTo (expectedMatch)
      matches(0).markAsCorrect shouldBe false
    }
  }

  "check" should "apply substitutions when computing `markAsCorrect`" in {
    val rule = typerighter.model.RegexRule(
      id = s"example-rule",
      category = Category("new-category", "New Category"),
      description = s"Example rule",
      replacement = Some(TextSuggestion("tea$1")),
      regex = new ComparableRegex("\\btea-? ?(shop|bag|leaf|leaves|pot)")
    )

    val validator = new RegexMatcher(List(rule))
    val eventuallyMatches = validator.check(
      MatcherRequest(getBlocks("I'm a little teapot"))
    )

    eventuallyMatches.map { matches =>
      matches.size shouldBe 1
      val expectedReplacement = Some("teapot")
      val expectedMatch = getMatch(
        "teapot",
        13,
        19,
        "I'm a little ",
        "",
        rule,
        expectedReplacement,
        markAsCorrect = true
      )
      matches(0) shouldMatchTo (expectedMatch)
    }
  }

  "check" should "apply substitutions when computing `markAsCorrect` - real world case" in {
    val rule = typerighter.model.RegexRule(
      id = s"example-rule",
      category = Category("new-category", "New Category"),
      description = s"Example rule",
      replacement = Some(TextSuggestion("Booker prize")),
      regex = new ComparableRegex("(?i)\\b(Man)? ?Booker prize")
    )

    val validator = new RegexMatcher(List(rule))
    val eventuallyMatches = validator.check(
      MatcherRequest(getBlocks("Somebody has won the Booker prize for their first novel"))
    )

    eventuallyMatches.map { matches =>
      matches.size shouldBe 1
      matches(0).replacement shouldBe Some(TextSuggestion(" Booker prize"))
      matches(0).markAsCorrect shouldBe true
    }
  }

  "check" should "handle multiple substitions" in {
    val rule = typerighter.model.RegexRule(
      id = s"example-rule",
      category = Category("new-category", "New Category"),
      description = s"Example rule",
      replacement = Some(TextSuggestion("$1-$2-long")),
      regex = new ComparableRegex(
        "\\b(one|two|three|four|five|six|seven|eight|nine|\\d)-? (year|day|month|week|mile)-? long"
      )
    )

    val validator = new RegexMatcher(List(rule))
    val eventuallyMatches = validator.check(
      MatcherRequest(getBlocks("A nine month long sabbatical"))
    )

    eventuallyMatches.map { matches =>
      matches.size shouldBe 1
      val expectedReplacement = Some("nine-month-long")
      val expectedMatch =
        getMatch("nine month long", 2, 17, "A ", " sabbatical", rule, expectedReplacement)
      matches(0) shouldMatchTo (expectedMatch)
    }
  }

  behavior of "capitalisations"

  it should "transform suggestions to respect sentence starts, to avoid suggesting capping down – preserve current case" in {
    val eventuallyMatches = checkTextWithRegex(
      new ComparableRegex("(?i)\\bcaf(e|é|è|ë|ê)"),
      "cafe",
      "Allowed to have up to 15 people in their home per day, and this rule applies to holiday accomodation. Cafes, bars, and restaurants will be able to seat 100 indoors and 200 outdoors, within the density limit"
    )

    eventuallyMatches.map { matches =>
      matches.size shouldBe 1
      val firstMatch = matches(0)
      firstMatch.replacement shouldBe Some(TextSuggestion("Cafe"))
      firstMatch.markAsCorrect shouldBe true
    }
  }

  it should "transform suggestions to respect sentence starts, to avoid suggesting capping down – cap up sentence start" in {
    val eventuallyMatches = checkTextWithRegex(
      new ComparableRegex("(?i)\\bcaf(e|é|è|ë|ê)"),
      "cafe",
      "Allowed to have up to 15 people in their home per day, and this rule applies to holiday accomodation. cafes, bars, and restaurants will be able to seat 100 indoors and 200 outdoors, within the density limit"
    )

    eventuallyMatches.map { matches =>
      matches.size shouldBe 1
      val firstMatch = matches(0)
      firstMatch.replacement shouldBe Some(TextSuggestion("Cafe"))
      firstMatch.markAsCorrect shouldBe false
    }
  }

  it should "transform suggestions to respect sentence starts, to avoid suggesting capping down – cap up sentence start within quote" in {
    val eventuallyMatches = checkTextWithRegex(
      new ComparableRegex("(?i)\\bcaf(e|é|è|ë|ê)"),
      "cafe",
      "Allowed to have up to 15 people in their home per day, and this rule applies to holiday accomodation. \"Cafes\", bars, and restaurants will be able to seat 100 indoors and 200 outdoors, within the density limit"
    )

    eventuallyMatches.map { matches =>
      matches.size shouldBe 1
      val firstMatch = matches(0)
      firstMatch.replacement shouldBe Some(TextSuggestion("Cafe"))
      firstMatch.markAsCorrect shouldBe true
    }
  }

  it should "should not apply capitalisations when the match does not include the start of the word" in {
    val eventuallyMatches = checkTextWithRegex(
      new ComparableRegex("(?i)af(e|é|è|ë|ê)"),
      "afe",
      "Allowed to have up to 15 people in their home per day, and this rule applies to holiday accomodation. Cafes, bars, and restaurants will be able to seat 100 indoors and 200 outdoors, within the density limit"
    )

    eventuallyMatches.map { matches =>
      matches.size shouldBe 1
      val firstMatch = matches(0)
      firstMatch.replacement shouldBe Some(TextSuggestion("afe"))
      firstMatch.markAsCorrect shouldBe true
    }
  }
}
